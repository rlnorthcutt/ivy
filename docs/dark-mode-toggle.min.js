/*!
 * Dark Mode Toggle Web Element
 * Version: 1.0.0
 * URL: https://github.com/rlnorthcutt/dark-mode-toggle
 * License: MIT (https://opensource.org/licenses/MIT)
 */

/* * Overview:
 * - Dependency-free Custom Element that toggles dark mode using either:
 *   (A) html[data-theme="dark"]  (strategy="attr", default), or
 *   (B) html.dark                (strategy="class", Tailwind style)
 * - Honors persisted user choice, existing page state (SSR/early script), and OS preference.
 * - Syncs across tabs (storage) and within the same page (BroadcastChannel + CustomEvent).
 * - Accessible switch semantics (role="switch", aria-checked).
 *
 * Usage:
 *   <dark-mode-toggle
 *     theme="auto|light|dark"   (default: auto)
 *     strategy="attr|class"     (default: attr)
 *     root="#app"               (default: html)
 *     dark-class="dark"         (default: dark)
 *     persist="off"             (omit to enable persistence)
 *   ></dark-mode-toggle>
 *
 * Notes:
 * - localStorage key: "dm:theme" ('light'|'dark')
 * - Window event:   themechange  (detail: { mode })
 * - Element event:  change       (detail: { mode })
 * - To avoid FOUC, consider a tiny pre-paint snippet in <head> that sets initial color-scheme.
 */

(() => {
  'use strict';

  /* ================================================================================================
   * Icon defaults (slottable). Consumers may override via:
   *   <svg slot="sun">...</svg>   and/or   <svg slot="moon">...</svg>
   * Both SVGs inherit currentColor from CSS for easy theming.
   * ============================================================================================== */
  const SUN_ICON = `
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M18.1 5.1c0 .3-.1.6-.3.9l-1.4 1.4-.9-.8 2.2-2.2c.3.1.4.4.4.7zm-.5 5.3h3.2c0 .3-.1.6-.4.9s-.5.4-.8.4h-2v-1.3zm-6.2-5V2.2c.3 0 .6.1.9.4s.4.5.4.8v2h-1.3zm6.4 11.7c-.3 0-.6-.1-.8-.3l-1.4-1.4.8-.8 2.2 2.2c-.2.2-.5.3-.8.3zM6.2 4.9c.3 0 .6.1.8.3l1.4 1.4-.8.9-2.2-2.3c.2-.2.5-.3.8-.3zm5.2 11.7h1.2v3.2c-.3 0-.6-.1-.9-.4s-.4-.5-.4-.8l.1-2zm-7-6.2h2v1.2H3.2c0-.3.1-.6.4-.9s.5-.3.8-.3zM6.2 16l1.4-1.4.8.8-2.2 2.2c-.2-.2-.3-.5-.3-.8s.1-.6.3-.8z"/>
      <circle cx="12" cy="11" r="4"/>
    </svg>
  `;
  const MOON_ICON = `
    <svg viewBox="0 0 20 20" aria-hidden="true">
      <path d="M17.39 15.14A7.33 7.33 0 0 1 11.75 1.6c.23-.11.56-.23.79-.34a8.19 8.19 0 0 0-5.41.45 9 9 0 1 0 7 16.58 8.42 8.42 0 0 0 4.29-3.84 5.3 5.3 0 0 1-1.03.69z"/>
    </svg>
  `;

  /* ================================================================================================
   * Template & Styles
   * - Single adoptedStyleSheet instance for perf; shadow encapsulation avoids CSS bleed.
   * - CSS variables + ::part targets allow external theming without piercing the shadow.
   * ============================================================================================== */
  const TPL = document.createElement('template');
  TPL.innerHTML = `
    <button part="button" class="track" type="button" role="switch" aria-checked="false" aria-label="Toggle dark mode">
      <span class="icon sun" part="sun" aria-hidden="true"><slot name="sun">${SUN_ICON}</slot></span>
      <span class="icon moon" part="moon" aria-hidden="true"><slot name="moon">${MOON_ICON}</slot></span>
      <span class="thumb" part="thumb" aria-hidden="true"></span>
    </button>
  `;

  const CSS = `
    :host{display:inline-block;vertical-align:middle;color-scheme:light dark}
    .track{cursor:pointer;display:flex;align-items:center;justify-content:space-around;padding:0 4px;
      width:var(--track-width,60px);height:var(--track-height,30px);background:var(--track-bg-light,#E9E9EA);
      border-radius:30px;position:relative;border:0;outline:none;transition:background-color .25s ease}
    .track:focus-visible{outline:2px solid color-mix(in oklab, CanvasText 30%, transparent);outline-offset:2px}
    .thumb{position:absolute;top:2px;left:2px;width:calc(var(--track-height,30px) - 4px);height:calc(var(--track-height,30px) - 4px);
      background:var(--thumb-bg,#fff);border-radius:50%;box-shadow:0 1px 3px rgba(0,0,0,.2);
      transition:transform .25s cubic-bezier(.25,.46,.45,.94),background-color .25s ease}
    .icon{display:inline-flex;align-items:center;justify-content:center;
      width:calc(var(--track-height,30px) - 8px);height:calc(var(--track-height,30px) - 8px);pointer-events:none;z-index:1}
    .icon svg{width:100%;height:100%;fill:currentColor;transition:color .25s ease,fill .25s ease}
    .sun{color:var(--icon-sun-color,#000)}
    .moon{color:var(--icon-moon-color,#8E8E93)}
    :host([_state="dark"]) .track{background:var(--track-bg-dark,#4D4D52)}
    :host([_state="dark"]) .thumb{transform:translateX(calc(var(--track-width,60px) - var(--track-height,30px)));background:var(--thumb-bg-dark,#6E6E73)}
    :host([_state="dark"]) .sun{color:var(--icon-sun-color-inactive,#8E8E93)}
    :host([_state="dark"]) .moon{color:var(--icon-moon-color-active,#fff)}
    @media (prefers-reduced-motion:reduce){.thumb,.track,.icon svg{transition:none}}
  `;
  const sheet = new CSSStyleSheet(); sheet.replaceSync(CSS);

  /* ================================================================================================
   * Constants / helpers
   * ============================================================================================== */
  /** localStorage key used to persist user choice ('light'|'dark'). */
  const KEY = 'dm:theme';
  /** BroadcastChannel name (same as KEY) for same-tab component sync. */
  const CH_NAME = KEY;
  /** Media query mirror; used to react to OS theme changes in auto mode. */
  const MQ = matchMedia('(prefers-color-scheme: dark)');
  /** Returns whether the OS currently prefers dark. */
  const isDarkOS = () => MQ.matches;
  /**
   * Resolves the root element being toggled. Defaults to <html>.
   * If a custom selector fails to resolve, falls back to <html>.
   */
  const getRoot = (sel) => (sel && sel !== 'html')
    ? (document.querySelector(sel) || document.documentElement)
    : document.documentElement;

  // Optional same-tab BroadcastChannel (older browsers may lack support).
  let bc; try { bc = new BroadcastChannel(CH_NAME); } catch {}

  /* ================================================================================================
   * <dark-mode-toggle> definition
   * ============================================================================================== */

  /**
   * DarkModeToggle
   * Lightweight, framework-agnostic theme switch with:
   * - dual strategy (attr/class),
   * - multi-source resolution (persisted → existing root → OS),
   * - cross-context sync (storage/BroadcastChannel),
   * - a11y switch semantics.
   */
  class DarkModeToggle extends HTMLElement {
    /** Attributes observed -> mirrors of the public API. */
    static get observedAttributes() { return ['theme','strategy','root','dark-class','persist']; }

    constructor(){
      super();
      // Shadow DOM + adoptedStyleSheets for encapsulated, fast styling
      const root = this.attachShadow({ mode:'open', delegatesFocus:true });
      root.adoptedStyleSheets = [sheet];
      root.appendChild(TPL.content.cloneNode(true));

      // Cached references and pre-bound handlers (avoid re-allocations)
      this._btn = root.querySelector('button');
      this._mo = new MutationObserver(() => this._reflectFromRoot());
      this._onClick = this._onClick.bind(this);
      this._onKey = this._onKey.bind(this);
      this._onStorage = this._onStorage.bind(this);
      this._onMQ = () => this._apply(); // react to OS flips when theme="auto"
      this._onBC = (e) => { if (e?.data?.type === 'themechange') this._applyFromExternal(e.data.mode); };
    }

    /* -------------------------------- Lifecycle -------------------------------- */

    connectedCallback(){
      // Attribute defaults live on the element for serializability and author CSS hooks
      if (!this.hasAttribute('theme')) this.setAttribute('theme','auto');
      if (!this.hasAttribute('strategy')) this.setAttribute('strategy','attr'); // 'attr' | 'class'
      if (!this.hasAttribute('dark-class')) this.setAttribute('dark-class','dark');

      // Wire events
      this._btn.addEventListener('click', this._onClick);
      this._btn.addEventListener('keydown', this._onKey);
      window.addEventListener('storage', this._onStorage);
      MQ.addEventListener?.('change', this._onMQ);
      bc?.addEventListener?.('message', this._onBC);

      // Initial state prefers: persisted → existing root → OS
      this._initFromRootOrStorage();
      this._apply();
      this._observeRoot(true);
    }

    disconnectedCallback(){
      // Cleanup listeners and observers
      this._btn.removeEventListener('click', this._onClick);
      this._btn.removeEventListener('keydown', this._onKey);
      window.removeEventListener('storage', this._onStorage);
      MQ.removeEventListener?.('change', this._onMQ);
      bc?.removeEventListener?.('message', this._onBC);
      this._observeRoot(false);
    }

    attributeChangedCallback(){ this._apply(); }

    /* ---------------------------- Public API (props) --------------------------- */

    /** 'auto'|'light'|'dark' – auto defers to persisted/existing/OS. */
    get theme(){ return (this.getAttribute('theme') || 'auto').toLowerCase(); }
    set theme(v){ this.setAttribute('theme', v); }

    /** 'attr' (data-theme) | 'class' (.dark) */
    get strategy(){ return (this.getAttribute('strategy') || 'attr').toLowerCase(); }
    /** CSS selector for the root to toggle; defaults to 'html'. */
    get rootSelector(){ return this.getAttribute('root') || 'html'; }
    /** Class used in class strategy; defaults to 'dark'. */
    get darkClass(){ return this.getAttribute('dark-class') || 'dark'; }
    /** Persistence toggle; persist="off" disables localStorage writes. */
    get persist(){ return this.getAttribute('persist') !== 'off'; }

    /* -------------------------------- Handlers -------------------------------- */

    /** Click toggles between 'light' and 'dark' (user intent overrides auto). */
    _onClick(){
      const next = this._current() === 'dark' ? 'light' : 'dark';
      this.theme = next;
      if (this.persist) { try { localStorage.setItem(KEY, next); } catch {} }
      this._broadcast(next);
      this._apply();
    }

    /** Keyboard activation: Space/Enter mimic click. */
    _onKey(e){
      if (e.key === ' ' || e.key === 'Enter'){ e.preventDefault(); this._onClick(); }
    }

    /** Cross-tab storage sync: reflect changes from other tabs/windows. */
    _onStorage(e){
      if (e.key === KEY) this.theme = e.newValue ?? 'auto';
    }

    /* ---------------------------- Core state logic ---------------------------- */

    /**
     * Resolve the effective mode:
     * 1) Explicit attribute (light/dark) → 2) persisted choice → 3) existing root → 4) OS
     */
    _current(){
      const attr = this.theme;
      if (attr === 'light' || attr === 'dark') return attr;

      // 2) persisted choice
      try {
        const stored = localStorage.getItem(KEY);
        if (stored === 'light' || stored === 'dark') return stored;
      } catch {}

      // 3) existing root state (SSR or pre-paint)
      const root = getRoot(this.rootSelector);
      if (this.strategy === 'class') {
        if (root.classList.contains(this.darkClass)) return 'dark';
      } else if (root.getAttribute('data-theme') === 'dark') {
        return 'dark';
      }

      // 4) OS preference
      return isDarkOS() ? 'dark' : 'light';
    }

    /**
     * Apply effective mode:
     * - Updates component state + a11y, then flips the chosen root via attr/class.
     * - Ensures UA widgets render correctly by setting color-scheme on <html>.
     * - Emits 'change' at element level for local subscribers.
     */
    _apply(){
      const mode = this._current();

      // Internal reflection for component styling and screen readers
      this.toggleAttribute('_state', false);
      this.setAttribute('_state', mode);
      this._btn.setAttribute('aria-checked', String(mode === 'dark'));

      // Flip the root according to strategy
      const root = getRoot(this.rootSelector);
      if (this.strategy === 'class') {
        root.classList.toggle(this.darkClass, mode === 'dark');
        // Avoid having both strategies active on <html>
        if (root === document.documentElement) document.documentElement.removeAttribute('data-theme');
      } else {
        root.setAttribute('data-theme', mode === 'dark' ? 'dark' : 'light');
        root.classList.remove(this.darkClass);
      }

      // Hint UA (forms, scrollbars) at the active palette
      if (root === document.documentElement) document.documentElement.style.colorScheme = mode;

      // Element-level event for app code colocated with the component
      this.dispatchEvent(new CustomEvent('change', { detail:{ mode } }));
    }

    /* ------------------------------ Cross-context ----------------------------- */

    /** Broadcast current mode within the same tab + dispatch a global event. */
    _broadcast(mode){
      try { bc?.postMessage({ type:'themechange', mode }); } catch {}
      window.dispatchEvent(new CustomEvent('themechange', { detail:{ mode } }));
    }

    /** Apply an external mode update (BroadcastChannel) and persist if enabled. */
    _applyFromExternal(mode){
      if (mode === 'light' || mode === 'dark') {
        this.theme = mode;
        if (this.persist) { try { localStorage.setItem(KEY, mode); } catch {} }
      }
      this._apply();
    }

    /* -------------------------------- Bootstrap -------------------------------- */

    /**
     * At connect time, if the root is already dark (via SSR/prepaint),
     * use that as the initial persisted value (when persistence is enabled).
     */
    _initFromRootOrStorage(){
      const root = getRoot(this.rootSelector);
      let found = null;
      if (this.strategy === 'class') {
        if (root.classList.contains(this.darkClass)) found = 'dark';
        else found = 'light'; 
      } else {
        const t = root.getAttribute('data-theme');
        if (t === 'dark') found = 'dark';
        else if (t === 'light') found = 'light'; 
      }
      if (found && this.persist) { try { localStorage.setItem(KEY, found); } catch {} }
    }

    /**
     * Observe the root for external flips (e.g., app code toggling theme).
     * Only mirrored into the component when theme="auto" so user overrides win.
     */
    _observeRoot(enable){
      const root = getRoot(this.rootSelector);
      if (!root) return;
      if (enable) {
        this._mo.observe(root, {
          attributes:true,
          attributeFilter: this.strategy === 'class' ? ['class'] : ['data-theme']
        });
      } else {
        this._mo.disconnect();
      }
    }

    /** Mirror external root changes into component state when theme="auto". */
    _reflectFromRoot(){
      if (this.theme !== 'auto') return;
      const root = getRoot(this.rootSelector);
      const externalDark = this.strategy === 'class'
        ? root.classList.contains(this.darkClass)
        : root.getAttribute('data-theme') === 'dark';

      this.setAttribute('_state', externalDark ? 'dark' : 'light');
      this._btn.setAttribute('aria-checked', String(externalDark));
      if (root === document.documentElement) {
        document.documentElement.style.colorScheme = externalDark ? 'dark' : 'light';
      }
    }
  }

  // Register the element once (idempotent guards left out for size).
  customElements.define('dark-mode-toggle', DarkModeToggle);
})();
